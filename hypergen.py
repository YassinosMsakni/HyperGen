# -*- coding: utf-8 -*-
"""Hypergen.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1l0PDq3E_nasOri4KiaK3h38mR6AExtIR
"""

from pip import main
import numpy as np
import pandas as pd
import random
from scipy.stats import norm
import os
from numpy.random import randint

def directed_hg_generator_uniform(output_path, dataset_name, num_hg=200, num_classes=99, num_nodes=100, num_he=150,
                     num_nodes_per_he=4,
                 mean_list=None, sd_list=None):

    # As function assumes equal number of head and tail nodes, check if parameter num_nodes_per_he is even
    if num_nodes_per_he % 2 != 0:
        raise Exception('provide an even number for parameter:num_nodes_per_he')

    # output_path check
    if not os.path.exists(output_path):
        try:
            os.makedirs(output_path)
        except Exception as ex:
            print('Please provide a valid output path')

    # Create output dataset folder
    output_dataset_name = os.path.join(output_path, dataset_name)
    if not os.path.exists(output_dataset_name):
        os.makedirs(output_dataset_name)
   
    # Set mean and sd for the normal distribution each class if not passed by user
    if mean_list is None:
        mean_list = [15] * num_classes
    if sd_list is None:
        sd_list = list(range(2, num_classes + 2))
   
    # Assign names to hyperedges, nodes and hypergraphs
    he_names = ['he_' + str(x) for x in (range(1, num_he + 1))]
    node_names = ['n_' + str(x) for x in (range(1, num_nodes + 1))]
    hypergraph_names = ['hg_' + str(x) for x in (range(1, num_hg + 1))]

    # Assign equal number of head and tail nodes to list
    list_nonzero = [1] * int((num_nodes_per_he/2)) + [-1] * int((num_nodes_per_he/2))
    # list of zeros (remaining elements of hyperedge)
    list_zeros = [0] * (num_nodes - num_nodes_per_he)
    # Initialize hypergraph matrix
    hx = []
   

    for he in range(num_he):
        # new_list = list_nonzero + list_zeros[:]
        # choose weights for the vertices randomly between integers 1 to 10 and append this list to the zeros list
        new_list = [a * b for a, b in zip(random.sample(range(1, 10), num_nodes_per_he), list_nonzero)] + \
        list_zeros
        # shuffle each hyperedge list
        random.shuffle(new_list)
        # asssign hyperedge list to hypergraph matrix
        hx.append(new_list)

    # if sum(np.sum(np.abs(h), axis=0)) == num_he:
    #   print('HG indicator matrix constructed!')
   
    hx = np.array(hx)
   
    hx = hx.T

       
       
    # output hypergraph matrix
    h_df = pd.DataFrame(hx)
    h_df.columns = he_names
    h_df.index = node_names
    h_df_file_name = os.path.join(output_dataset_name, dataset_name + '_h_indic_vertex_weighted.txt')
    h_df.to_csv(h_df_file_name, sep=' ')

    # Generate hyperedge weights
    he_weight_list = list()
    for m_s_elem in range(0, num_classes):
        for class_element in range(0, int(num_hg/num_classes)):
            weight_list = norm.rvs(size=num_he, loc=mean_list[m_s_elem], scale=sd_list[m_s_elem])
            weight_list.sort()
            he_weight_list.append([weight_list[:]])

    he_weight_df = pd.DataFrame(np.vstack(he_weight_list).T)
    he_weight_df.columns = hypergraph_names[:len(he_weight_df.columns)]
    he_weight_df.index = he_names
    he_weight_df_file_name = os.path.join(output_dataset_name, dataset_name + '_he_weight.txt')
    he_weight_df.to_csv(he_weight_df_file_name, sep=' ')

    anno_df = pd.DataFrame()
    anno_df['Samples'] =  hypergraph_names[:len(he_weight_df.columns)]
    anno_df['labels'] = np.hstack([['class_' + str(x)] * int(num_hg/num_classes) for x in range(1, num_classes + 1)])
    anno_file_name = os.path.join(output_dataset_name, dataset_name + '.txt')
    anno_df.to_csv(anno_file_name, sep=' ', index=False)

"""# Nouvelle section"""

def directed_hg_generator_non_uniform(output_path, dataset_name, num_hg=200, num_classes=3, num_nodes=100, num_he=150,
                             min_nodes_he=2, max_nodes_he=10, mean_list=None, sd_list=None):
    if min_nodes_he < 2:
        raise Exception('Minimum non zero nodes has to be greater ht')

    # output_path check
    if not os.path.exists(output_path):
        try:
            os.makedirs(output_path)
        except Exception as ex:
            print('Please provide a valid output path')

    # Create output dataset folder
    output_dataset_name = os.path.join(output_path, dataset_name)
    if not os.path.exists(output_dataset_name):
        os.makedirs(output_dataset_name)

    # Set mean and sd for the normal distribution each class if not passed by user
    if mean_list is None:
        mean_list = [15] * num_classes
    if sd_list is None:
        sd_list = list(range(2, num_classes + 2))

    # Assign names to hyperedges, nodes and hypergraphs
    he_names = ['he_' + str(x) for x in (range(1, num_he + 1))]
    node_names = ['n_' + str(x) for x in (range(1, num_nodes + 1))]
    hypergraph_names = ['hn_' + str(x) for x in (range(1, num_hg + 1))]

    # Initialize hypergraph matrix
    hx = []

    for he in range(num_he):
        tot_nodes_he = randint(min_nodes_he, max_nodes_he, 1)
        if tot_nodes_he == 2:
            pos = [1]
        else:
            pos = randint(1, tot_nodes_he-1, 1)
        neg = tot_nodes_he - pos
        list_nonzero = [1] * pos[0] + [-1] * neg[0]
        # list of zeros (remaining elements of hyperedge)
        list_zeros = [0] * (num_nodes - tot_nodes_he[0])
        # new_list = list_nonzero + list_zeros[:]
        # choose weights for the vertices randomly between integers 1 to 10 and append this list to the zeros list
        new_list = [a * b for a, b in zip(random.sample(range(1, 10), tot_nodes_he[0]), list_nonzero)] + \
                   list_zeros[:]
        # shuffle each hyperedge list
        random.shuffle(new_list)
        # asssign hyperedge list to hypergraph matrix
        hx.append(new_list)
       
    hx = np.array(hx)
   
    hx = hx.T

    # if sum(np.sum(np.abs(h), axis=0)) == num_he:
    #   print('HG indicator matrix constructed!')

    # output hypergraph matrix
    h_df = pd.DataFrame(hx)
    h_df.columns = he_names
    h_df.index = node_names
    h_df_file_name = os.path.join(output_dataset_name, dataset_name + '_h_indic_vertex_weighted.txt')
    h_df.to_csv(h_df_file_name, sep=' ')

    # Generate hyperedge weights
    he_weight_list = list()
    for m_s_elem in range(0, num_classes):
        for class_element in range(0, int(num_hg / num_classes)):
            weight_list = norm.rvs(size=num_he, loc=mean_list[m_s_elem], scale=sd_list[m_s_elem])
            weight_list.sort()
            he_weight_list.append([weight_list[:]])

    he_weight_df = pd.DataFrame(np.vstack(he_weight_list).T)
    he_weight_df.columns = hypergraph_names[:len(he_weight_df.columns)]
    he_weight_df.index = he_names
    he_weight_df_file_name = os.path.join(output_dataset_name, dataset_name + '_he_weight.txt')
    he_weight_df.to_csv(he_weight_df_file_name, sep=' ')

    anno_df = pd.DataFrame()
    anno_df['Samples'] = hypergraph_names[:len(he_weight_df.columns)]
    anno_df['labels'] = np.hstack([['class_' + str(x)] * int(num_hg / num_classes) for x in range(1, num_classes + 1)])
    anno_file_name = os.path.join(output_dataset_name, dataset_name + '.txt')
    anno_df.to_csv(anno_file_name, sep=' ', index=False)

directed_hg_generator_uniform('data/', 'Trial_syn_uniform_hg1',  num_hg=500)
directed_hg_generator_non_uniform('data/', 'Trial_syn_non_uniform_hg1',  num_hg=500)